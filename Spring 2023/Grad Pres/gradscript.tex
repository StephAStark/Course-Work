\input{settings}

\title{How the Structures and Equivalencies of Rings and Modules Can Yield Equivalent Codes}
\author{Stephanie Amber Klumpe}
\date{April 27, 2023}

\begin{document}

\maketitle
\newpage

\begin{enumerate}
    \item[Abstract:] \input{abstract} 
\end{enumerate}

Imagine you wanted to send a message through a comprimised or unreliable data channel. To ensure that
the desired recipiant got the message, you would want to encrypt your message, not only for security
reasons, but also to make sure that the whole message was delivered. If in particular, you were
concerned that some of the message would get lost in transmition, you could still encode it, however you
would likely want to do it in such a manner that any data lost wouldn't impact the message. One way, and
one of the most noteble ways is to use redundancy. Consider sending the message "Hi". Converting this to
binary, you would get "01001000 01101001". Using what is called Hamming code, we can encode this to
"0100101 1000110 0110110 1001001". This specific way of encoding a message was developed by Richard
Hamming, one of the pioneers of the field of Error Correction Codes and a well known mathematician in
the field of coding theory. For this example, we use his $[4,7]$ code to create the rendundancies. It
has this notation because it takes four bits of data and adds three extra bits in a special manner using
this matrix.
%Add matrix to slides.
This idea of ECC is used quite vastly in  the world of telecom from cell tower and satilite systems, to
computers and even game consols. This allows for the inevitable errors to happen with a way of detecting
them and also correcting some of them. This is becasue pieces of the encoded message can get corrupted
or go missing, and that is already accounted for from the extra three bits per four bit piece. ECC is a
bit of a misnomer as not all errors can be corrected, but with different methods, more or less errors
can be.\\

When it comes to encoding messages, we are used to using the our native alphabet, or even binary in some
cases, but we can actually change that up a bit. Consider for a moment the statements "Ich binn ein
berliner" and "I am a donut". These are the exact same statement. Alternitively, consider "Hello world"
and "Rovvy gybvn". These are also the same phrases. In both of these examples, we can get from one code
to another via a map between alphabets. In the latter case, it's a bit easier to define the map, as all
of the letters are shifted ten places to the right, so the map goes from our alphabet to itself. This is
the essence of detemining when codes are the same in the context of coding theory, even if they look
different on the surface. Like in algebra, we look at homomorphisms, in the study of metric spaces we
look at isometries, and in topology we look at homeomorphisms. We will be looking at in part what are
called linear isometries. For this, we will only concern ourselves with linear codes. These isometries
preserve what is called the Hamming weight, again named after Richard Hamming. This weight is simply the
number of nonzero elements in a code with respect to the alphabet. For example the letter "H" in the
word "Hi" has the binary representation "01001000". So, applying the Hamming weight to it, we get
$wt(01001000)=2$ as there are only two nonzero elements in this string relative to the alphabet
$\{0,1\}$. This, however, is not quite enough for us to say that two codes are equivalent in general.
For that, we need a few more ideas.\\

This leads us naturally to monomial transformations. A monomial transformation $T:C\to C'$ is a module
epimorphism given by $T(x_1,\ldots,x_n)=(x_{\sigma(1)}u_1,\ldots,x_{\sigma(n)}u_n)$ where $\sigma$ is a
permutation of the set $\{1,\ldots,n\}$ and $u_i\in R$ are units for $1\leq i\leq n$. This then plays 
into the question of if every surjective linear isometry is in fact a left monomial transformation.
Interestingly enough, this is indeed the case when the ring $R$ in question is a finite field instead.
This was shown by the mathematician MacWilliams. So, if you had two codes in a finite field such that
you could find an onto linear isometry between them, then they would have the same Hamming weight, and
also, each letter would just be the same as another in the other code, just in a different position. So,
we could say that the codes would be the same.\\



\end{document}